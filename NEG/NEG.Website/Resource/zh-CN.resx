<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AboutNEG" xml:space="preserve">
    <value>NEG简介</value>
  </data>
  <data name="AboutNEGBody" xml:space="preserve">
    <value>&lt;!--&lt;h3&gt;WHY IS NEG ?&lt;/h3&gt; --&gt;
                   &lt;h3&gt;为什么是 NEG ?&lt;/h3&gt; 
                   &lt;p&gt;
                        随着Newegg网站业务逐渐增加，前端交互日益复杂，旧版本的JS框架从性能，效果，业务上都满足不了开发需求；一个动态加载，擅长模块化的Javascript框架 NEG 可以很好地解决这个问题。
                    &lt;/p&gt;

                    &lt;br/&gt;

                    &lt;h3&gt;不是有jQuery了吗 ?&lt;/h3&gt; 
                    &lt;p&gt;
                        jQuery 是一个功能非常强大的工具类，但不能很好地解决动态加载，模块化的问题（如header里引入很多JS 文件），而NEG也和jQuery 很好地兼容，你可以在NEG里将jQuery作为一个模块来使用。
                    &lt;/p&gt;
&lt;br/&gt;
                    &lt;pre class="prettyprint lang-js"&gt;
NEG.run(function(require){
    var $ = require("Utility.jQuery");
    $("domID").addClass("test");
});&lt;/pre&gt;
&lt;br/&gt;
&lt;p&gt;
    $ 是私有变量，可以在function内任意使用；并且这次加载回来的jQuery并不是绑定在全局之下，所以不会对方法体外边有任何的影响
&lt;/p&gt;

                    &lt;style&gt;
                        .aboutNEG ol li{
                            padding-top:2px;
                            margin-top:2px;
                        }
                    &lt;/style&gt;

                   &lt;h3&gt;关于NEG &lt;/h3&gt; 
                   &lt;p&gt;
                    &lt;ol style="padding-left:20px;"&gt;
                        &lt;li&gt;
                            NEG 提供了丰富、易用的API以及详细的说明。
                        &lt;/li&gt;
                        &lt;li&gt;
                            NEG 可能会带给你崭新的编程习惯。
                        &lt;/li&gt;
                        &lt;li&gt;
                            NEG 为后续合并JS文件等进一步优化前端架构提供了接口。
                        &lt;/li&gt;
                        &lt;li&gt;
                            NEG 为跨平台，多终端提供了接口。
                        &lt;/li&gt;
                    &lt;/ol&gt;
                   &lt;/p&gt;</value>
  </data>
  <data name="Example" xml:space="preserve">
    <value>举例</value>
  </data>
  <data name="Introductory" xml:space="preserve">
    <value>[NEG.JS] 简介</value>
  </data>
  <data name="IntroductoryStep1" xml:space="preserve">
    <value>NEG最重要的一个特质：代码在沙箱里执行。</value>
  </data>
  <data name="Parameter" xml:space="preserve">
    <value>参数</value>
  </data>
  <data name="QuickStartStep1" xml:space="preserve">
    <value>首先，来定义一个Module</value>
  </data>
  <data name="QuickStartStep2" xml:space="preserve">
    <value>然后，在NEG沙箱里Require回来，并使用</value>
  </data>
  <data name="Return" xml:space="preserve">
    <value>返回值</value>
  </data>
  <data name="Setup" xml:space="preserve">
    <value>安装</value>
  </data>
  <data name="SetupStep1" xml:space="preserve">
    <value>&lt;a href="{0}"&gt;下载&lt;/a&gt;并解压缩 NEG.JS </value>
  </data>
  <data name="SetupStep2" xml:space="preserve">
    <value>将 &lt;pre class="prettyprint inline"&gt;release&lt;/pre &gt; 目录拷贝到网站目录JS下，找到 &lt;pre class="prettyprint inline"&gt;{0}.js&lt;/pre&gt;，然后引入到页面</value>
  </data>
  <data name="Summary" xml:space="preserve">
    <value>简介</value>
  </data>
  <data name="Syntax" xml:space="preserve">
    <value>语法</value>
  </data>
  <data name="Tutorial" xml:space="preserve">
    <value>教程</value>
  </data>
</root>